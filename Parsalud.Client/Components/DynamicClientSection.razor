@using System.Text.RegularExpressions

@inject ISectionService Service

<dynamic-client-section @key=@id style=@Style>
    @if (!string.IsNullOrWhiteSpace(prevHtml))
    {
        @RenderDynamicContent(prevHtml)
    }
</dynamic-client-section>

@code {
    [Parameter]
    [EditorRequired]
    public required string Html { get; set; }

    [Parameter]
    public string? Style { get; set; }

    private string? prevHtml;
    private int id;

    private readonly Dictionary<string, Type> componentMappings = new()
    {
        { "Style", typeof(Style) },
        { "CurrentPageTitle", typeof(CurrentPageTitle) },
        { "DynamicSection", typeof(DynamicSection) },
        { "Carousel", typeof(Carousel) },
        { "LatestPostsSection", typeof(LatestPostsSection) }
        // Agrega más componentes aquí según los que pueden llegar desde la base de datos.
    };

    protected override void OnParametersSet()
    {
        if (prevHtml == Html)
        {
            return;
        }

        prevHtml = Html;
        id++;
    }

    private RenderFragment RenderDynamicContent(string html) => builder =>
    {
        int seq = 0;
        var regex = new Regex(@"<(\w+)([^>]*)\s*/?>");
        var matches = regex.Matches(html);
        int lastIndex = 0;

        foreach (Match match in matches)
        {
            string tagName = match.Groups[1].Value;
            string attributes = match.Groups[2].Value;
            int matchIndex = match.Index;

            // Agregar el HTML anterior al componente como MarkupContent
            builder.AddMarkupContent(seq++, html[lastIndex..matchIndex]);

            if (componentMappings.TryGetValue(tagName, out Type? componentType))
            {
                // Extraer atributos y convertirlos en parámetros dinámicos
                var parameters = ParseAttributes(attributes);

                builder.OpenComponent(seq++, componentType);
                foreach (var param in parameters)
                {
                    builder.AddAttribute(seq++, param.Key, param.Value);
                }
                builder.CloseComponent();
            }
            else
            {
                // Si la etiqueta no está en componentMappings, agregarla como texto sin procesar
                builder.AddMarkupContent(seq++, match.Value);
            }

            lastIndex = matchIndex + match.Length;
        }

        // Agregar cualquier contenido HTML restante después del último componente
        builder.AddMarkupContent(seq++, html[lastIndex..]);
    };

    private Dictionary<string, object> ParseAttributes(string attributes)
    {
        var result = new Dictionary<string, object>();
        var attrRegex = new Regex(@"(\w+)=""(.*?)""");
        var attrMatches = attrRegex.Matches(attributes);

        foreach (var group in attrMatches.Select(x => x.Groups))
        {
            result[group[1].Value] = group[2].Value;
        }

        return result;
    }
}