@using System.Text.RegularExpressions
@using Microsoft.Extensions.Caching.Memory
@using System.Text

@inject IMemoryCache MemoryCache
@inject ISectionService Service
@inject NavigationManager NM

@if (!string.IsNullOrWhiteSpace(content))
{
    @RenderDynamicContent(content)
}

@code {
    [Parameter]
    [EditorRequired]
    public required string Code { get; set; }

    [Parameter]
    public Guid? LiveServerId { get; set; }

    [Parameter]
    public int? I { get; set; }

    [Parameter]
    public string? Param1 { get; set; }

    [Parameter]
    public string? Param2 { get; set; }

    [Parameter]
    public string? Param3 { get; set; }

    [Parameter]
    public string? Param4 { get; set; }

    [Parameter]
    public string? Param5 { get; set; }

    [Parameter]
    public string? Param6 { get; set; }

    private Guid? prevLiveServerId;
    private string? prevCode;
    private int? prevI;
    private string? content;
    private readonly Dictionary<string, Type> componentMappings = new()
    {
        { "CurrentPageTitle", typeof(CurrentPageTitle) },
        { "DynamicSection", typeof(DynamicSection) },
        { "Carousel", typeof(Carousel) },
        { "LatestPostsSection", typeof(LatestPostsSection) }
        // Agrega más componentes aquí según los que pueden llegar desde la base de datos.
    };

    protected override async Task OnParametersSetAsync()
    {
        if (prevI == I &&
            prevCode == Code &&
            prevLiveServerId == LiveServerId)
            return;

        prevI = I;
        prevCode = Code;
        prevLiveServerId = LiveServerId;

        if (LiveServerId.HasValue)
        {
            var ls = MemoryCache.Get<LiveServerInstance>($"LiveServer-{LiveServerId}");
            if (ls is not null)
            {
                StringBuilder sb = new();
                if (!string.IsNullOrWhiteSpace(ls.Css))
                {
                    sb.AppendLine("<style>");
                    sb.AppendLine("@import url('css/bundle.min.css');");
                    sb.AppendLine(ls.Css);
                    sb.AppendLine("</style>");
                }
                if (!string.IsNullOrWhiteSpace(ls.Html))
                {
                    sb.AppendLine(ls.Html);
                }
                content = sb.ToString();
                return;
            }
        }

        var response = await Service.GetByCodeAsync(
            Code,
            Param1,
            Param2,
            Param3,
            Param4,
            Param5,
            Param6);

        if (response.IsSuccessWithData)
        {
            content = response.Data.Content;
        }
        else
        {
            NM.NavigateTo("NotFound", replace: true);
        }
    }

    private RenderFragment RenderDynamicContent(string html) => builder =>
    {
        int seq = 0;
        var regex = new Regex(@"<(\w+)([^>]*)\s*/?>");
        var matches = regex.Matches(html);
        int lastIndex = 0;

        foreach (Match match in matches)
        {
            string tagName = match.Groups[1].Value;
            string attributes = match.Groups[2].Value;
            int matchIndex = match.Index;

            // Agregar el HTML anterior al componente como MarkupContent
            builder.AddMarkupContent(seq++, html[lastIndex..matchIndex]);

            if (componentMappings.TryGetValue(tagName, out Type? componentType))
            {
                // Extraer atributos y convertirlos en parámetros dinámicos
                var parameters = ParseAttributes(attributes);

                builder.OpenComponent(seq++, componentType);
                foreach (var param in parameters)
                {
                    builder.AddAttribute(seq++, param.Key, param.Value);
                }
                builder.CloseComponent();
            }
            else
            {
                // Si la etiqueta no está en componentMappings, agregarla como texto sin procesar
                builder.AddMarkupContent(seq++, match.Value);
            }

            lastIndex = matchIndex + match.Length;
        }

        // Agregar cualquier contenido HTML restante después del último componente
        builder.AddMarkupContent(seq++, html[lastIndex..]);
    };

    private Dictionary<string, object> ParseAttributes(string attributes)
    {
        var result = new Dictionary<string, object>();
        var attrRegex = new Regex(@"(\w+)=""(.*?)""");
        var attrMatches = attrRegex.Matches(attributes);

        foreach (var group in attrMatches.Select(x => x.Groups))
        {
            result[group[1].Value] = group[2].Value;
        }

        return result;
    }
}